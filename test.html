<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASCII Art Image Converter</title>
  <!-- Add Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Space+Mono&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Dark theme only */
      --background: #121212;
      --text: #E0E0E0;
      --accent: #FF0000; /* Brighter red */
      --hover: #FF3333; /* Brighter hover red */
      --panel: #1E1E1E;
      --border: #333333;
      --dark-panel: #252525;
    }

    /* Remove light theme variables */
    :root.light-theme {
      --background: #FFFFFF;
      --text: #333333;
      --accent: #FF0000; /* Brighter red */
      --hover: #FF3333; /* Brighter hover red */
      --panel: #F5F5F5;
      --border: #E0E0E0;
      --dark-panel: #EFEFEF;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Poppins', sans-serif;
    }

    body {
      background-color: var(--background);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      background-image: radial-gradient(circle at 10% 20%, rgba(139, 0, 0, 0.05) 0%, transparent 70%);
    }

    .container {
      max-width: 1200px;
      width: 100%;
    }

    header {
      text-align: center;
      margin-bottom: 40px;
      position: relative;
      padding: 20px 0;
    }

    h1 {
      font-size: 3rem;
      font-weight: 600;
      /* Removed text-shadow glow */
      letter-spacing: 2px;
      margin-bottom: 15px;
      position: relative;
      background: linear-gradient(90deg, #333333, #8B0000);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    h1::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 150px;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
    }

    .subtitle {
      opacity: 0.8;
      font-size: 1.2rem;
      margin-bottom: 20px;
      font-weight: 300;
    }

    /* Updated panels layout */
    .panels {
      display: flex;
      flex-direction: column;
      gap: 30px;
      margin-bottom: 40px;
    }

    @media (min-width: 768px) {
      .panels {
        flex-direction: row;
      }
    }

    .panel {
      flex: 1;
      background-color: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 25px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .panel:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
    }

    .panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
    }

    .panel-title {
      font-size: 1.4rem;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }

    .panel-title::before {
      content: '>';
      color: var(--accent);
    }

    /* Updated drop area */
    .drop-area {
      border: 2px dashed var(--border);
      border-radius: 12px;
      min-height: 220px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      background-color: var(--dark-panel);
    }

    .drop-area.active {
      border-color: var(--accent);
      background-color: rgba(139, 0, 0, 0.05);
    }

    .drop-area:hover {
      border-color: var(--hover);
      transform: scale(1.01);
    }

    .drop-text {
      text-align: center;
      pointer-events: none;
      padding: 20px;
    }

    .drop-text p {
      margin: 5px 0;
    }

    .drop-text p:first-child {
      font-size: 1.2rem;
      font-weight: 600;
    }

    /* Updated button styles */
    .upload-btn {
      margin-top: 25px;
      padding: 12px 25px;
      background-color: transparent;
      border: 2px solid var(--accent);
      color: var(--text);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      font-weight: 500;
      letter-spacing: 1px;
    }

    .upload-btn:hover {
      background-color: rgba(139, 0, 0, 0.1);
      box-shadow: 0 0 15px rgba(139, 0, 0, 0.3);
      transform: translateY(-2px);
    }

    .upload-btn::before {
      content: '';
      position: absolute;
      top: -100%;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(139, 0, 0, 0.2), transparent);
      transition: all 0.5s ease;
    }

    .upload-btn:hover::before {
      top: 0;
    }

    /* Updated controls */
    .controls {
      margin-top: 30px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      background-color: var(--dark-panel);
      padding: 20px;
      border-radius: 10px;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .control-label {
      min-width: 120px;
      font-weight: 500;
    }

    /* Updated toggle switch */
    .toggle-wrapper {
      position: relative;
      width: 60px;
      height: 30px;
    }

    .toggle {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--panel);
      border: 1px solid var(--border);
      transition: 0.4s;
      border-radius: 30px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 3px;
      background-color: var(--accent);
      transition: 0.4s;
      border-radius: 50%;
    }

    .toggle:checked + .toggle-slider {
      background-color: rgba(139, 0, 0, 0.1);
    }

    .toggle:checked + .toggle-slider:before {
      transform: translateX(30px);
    }

    /* Updated size buttons */
    .size-options {
      display: flex;
      gap: 10px;
    }

    .size-btn {
      padding: 8px 15px;
      background-color: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
    }

    .size-btn.active {
      background-color: rgba(139, 0, 0, 0.1);
      border-color: var(--accent);
      box-shadow: 0 0 5px rgba(139, 0, 0, 0.3);
    }

    .size-btn:hover:not(.active) {
      border-color: var(--hover);
      transform: translateY(-2px);
    }

    /* Updated output container */
    .output-container {
      position: relative;
      min-height: 300px;
      background-color: var(--dark-panel); /* Use theme variable */
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: auto;
      padding: 15px;
      margin-top: 10px;
      white-space: pre;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      line-height: 1;
      position: relative;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
    }
    
    .crt-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(139, 0, 0, 0) 50%, rgba(139, 0, 0, 0.03) 50%);
      background-size: 100% 4px;
      z-index: 1;
      pointer-events: none;
      opacity: 0.15;
    }

    .crt-effect::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(18, 16, 16, 0.1);
      opacity: 0;
      z-index: 2;
      pointer-events: none;
      animation: flicker 0.3s infinite;
    }

    .ascii-output {
      position: relative;
      z-index: 0;
    }

    /* Updated action buttons */
    .action-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    .save-btn {
      padding: 10px 20px;
      background-color: transparent;
      border: 2px solid var(--accent);
      color: var(--text);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 500;
    }

    .save-btn:hover {
      background-color: rgba(139, 0, 0, 0.1);
      box-shadow: 0 0 10px rgba(139, 0, 0, 0.3);
      transform: translateY(-2px);
    }

    .save-btn .icon {
      display: inline-block;
      font-size: 1.2rem;
    }

    .save-btn:hover .icon {
      animation: glitch 1s infinite;
    }

    /* Updated loading spinner */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(5px);
    }

    .loading.active {
      opacity: 1;
      pointer-events: auto;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(139, 0, 0, 0.1);
      border-left-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Animations */
    @keyframes glitch {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      50% { transform: translateX(2px); }
      75% { transform: translateX(-1px); }
    }

    @keyframes flicker {
      0%, 100% { opacity: 0.1; }
      50% { opacity: 0; }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .hidden {
      display: none;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      h1 {
        font-size: 2.2rem;
      }
      
      .control-group {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .size-options {
        margin-top: 5px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <!-- Removed theme toggle icon -->
      <h1>ASCII Art Converter</h1>
      <p class="subtitle">Transform your images into beautiful ASCII art</p>
    </header>
    
    <div class="panels">
      <div class="panel">
        <h2 class="panel-title">Input</h2>
        <div id="dropArea" class="drop-area">
          <!-- Remove this line -->
          <!-- <canvas id="matrixCanvas" class="matrix-bg"></canvas> -->
          <div class="drop-text">
            <p>Drag & drop image here</p>
            <p>(JPG, PNG, GIF)</p>
          </div>
          <input type="file" id="fileInput" accept="image/*" class="hidden" />
          <button id="uploadBtn" class="upload-btn">Select File</button>
        </div>
        
        <div class="controls">
          <div class="control-group">
            <span class="control-label">Color Output:</span>
            <div class="toggle-wrapper">
              <input type="checkbox" id="colorToggle" class="toggle">
              <label for="colorToggle" class="toggle-slider"></label>
            </div>
          </div>
          
          <div class="control-group">
            <span class="control-label">Size:</span>
            <div class="size-options">
              <button class="size-btn" data-size="small">Small</button>
              <button class="size-btn active" data-size="medium">Medium</button>
              <button class="size-btn" data-size="large">Large</button>
            </div>
          </div>
          
          <div class="control-group">
            <span class="control-label">Background:</span>
            <div class="toggle-wrapper">
              <input type="checkbox" id="bgToggle" class="toggle">
              <label for="bgToggle" class="toggle-slider"></label>
            </div>
            <span class="toggle-label">White / Black</span>
          </div>
          
          <!-- Removed theme toggle from here -->
        </div>
      </div>
      
      <div class="panel">
        <h2 class="panel-title">Output</h2>
        <div class="output-container">
          <div class="crt-effect"></div>
          <pre id="asciiOutput" class="ascii-output">ASCII output will appear here...</pre>
        </div>
        
        <div class="action-buttons">
          <button id="saveBtn" class="save-btn">
            <span class="icon">üíæ</span>
            Save as PNG
          </button>
        </div>
      </div>
    </div>
    
    <!-- Removing the features section entirely -->
    
    <div id="loading" class="loading">
      <div class="spinner"></div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // DOM Elements
      const dropArea = document.getElementById('dropArea');
      const fileInput = document.getElementById('fileInput');
      const uploadBtn = document.getElementById('uploadBtn');
      const colorToggle = document.getElementById('colorToggle');
      const bgToggle = document.getElementById('bgToggle');
      const sizeBtns = document.querySelectorAll('.size-btn');
      const asciiOutput = document.getElementById('asciiOutput');
      const saveBtn = document.getElementById('saveBtn');
      const loading = document.getElementById('loading');
      
      // Variables
      let currentImage = null;
      let currentSize = 'medium';
      let useColor = false;
      let useWhiteBg = false; // Default to black background
      
      // Event Listeners
      uploadBtn.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', handleFileSelect);
      
      // Drag and drop events
      dropArea.addEventListener('dragover', handleDragOver);
      dropArea.addEventListener('dragleave', handleDragLeave);
      dropArea.addEventListener('drop', handleDrop);
      
      // Controls
      colorToggle.addEventListener('change', () => {
        useColor = colorToggle.checked;
        if (currentImage) processImage(currentImage);
      });
      
      // Add background toggle handler
      bgToggle.addEventListener('change', () => {
        useWhiteBg = bgToggle.checked; // Toggle is for white background
        updateBackgroundColor();
        if (currentImage) processImage(currentImage);
      });
      
      // Set initial background color
      function updateBackgroundColor() {
        const outputContainer = document.querySelector('.output-container');
        if (useWhiteBg) {
          outputContainer.style.backgroundColor = '#FFFFFF';
          asciiOutput.style.color = '#000000';
        } else {
          outputContainer.style.backgroundColor = '#050505';
          asciiOutput.style.color = '#FAFAFA';
        }
      }
      
      // Initialize background to black
      updateBackgroundColor();
      
      // Size buttons event listeners
      sizeBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          sizeBtns.forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          currentSize = e.target.dataset.size;
          if (currentImage) processImage(currentImage);
        });
      });
      
      // Save button
      saveBtn.addEventListener('click', saveAsImage);
      
      // Functions
      function handleDragOver(e) {
        e.preventDefault();
        dropArea.classList.add('active');
      }
      
      function handleDragLeave(e) {
        e.preventDefault();
        dropArea.classList.remove('active');
      }
      
      function handleDrop(e) {
        e.preventDefault();
        dropArea.classList.remove('active');
        
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
          const file = e.dataTransfer.files[0];
          handleFile(file);
        }
      }
      
      function handleFileSelect(e) {
        if (e.target.files && e.target.files[0]) {
          const file = e.target.files[0];
          handleFile(file);
        }
      }
      
      function handleFile(file) {
        // Check if file is an image
        if (!file.type.match('image.*')) {
          alert('Please select an image file (JPG, PNG, GIF).');
          return;
        }
        
        loading.classList.add('active');
        
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            currentImage = img;
            processImage(img);
            loading.classList.remove('active');
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }
      
      function processImage(img) {
        // Set dimensions based on size
        let width;
        switch (currentSize) {
          case 'small':
            width = 60;
            break;
          case 'large':
            width = 120;
            break;
          default: // medium
            width = 80;
        }
        
        // Calculate height to maintain aspect ratio
        const ratio = img.height / img.width;
        const height = Math.floor(width * ratio); // Removed division by 2 for better proportions
        
        // Create canvas to process image
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        // Get image data
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // Convert to ASCII
        let asciiArt = '';
        const asciiChars = ['@', '%', '#', '*', '+', '=', '-', ':', '.', ' ']; // Reversed for better contrast
        
        if (useColor) {
          // Color version
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = (y * width + x) * 4;
              const r = data[idx];
              const g = data[idx + 1];
              const b = data[idx + 2];
              
              // Calculate brightness
              const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
              const charIndex = Math.floor(brightness / 255 * (asciiChars.length - 1));
              const char = asciiChars[charIndex];
              
              // Add colored span with consistent width
              asciiArt += `<span style="color: rgb(${r},${g},${b}); display: inline-block; width: 0.6em;">${char}</span>`;
            }
            asciiArt += '<br>';
          }
          asciiOutput.innerHTML = asciiArt;
          asciiOutput.style.lineHeight = '1em';
          asciiOutput.style.letterSpacing = '0';
        } else {
          // Monochrome version
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = (y * width + x) * 4;
              const r = data[idx];
              const g = data[idx + 1];
              const b = data[idx + 2];
              
              // Calculate brightness
              const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
              const charIndex = Math.floor(brightness / 255 * (asciiChars.length - 1));
              asciiArt += asciiChars[charIndex];
            }
            asciiArt += '\n';
          }
          asciiOutput.textContent = asciiArt;
          asciiOutput.style.lineHeight = '1em';
          asciiOutput.style.letterSpacing = '0';
        }
      }
      
      function saveAsImage() {
        if (!currentImage) {
          alert('Please convert an image first');
          return;
        }
        
        // Create a new canvas
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Set dimensions
        const outputContainer = document.querySelector('.output-container');
        canvas.width = outputContainer.clientWidth;
        canvas.height = outputContainer.clientHeight;
        
        // Set background based on toggle
        context.fillStyle = useWhiteBg ? '#FFFFFF' : '#050505';
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add text
        context.font = window.getComputedStyle(asciiOutput).font;
        context.fillStyle = useWhiteBg ? '#000000' : '#FAFAFA';
        
        // Handle the different output types
        if (useColor) {
          // For colored output, need to use html2canvas or similar
          // This is a simplified version that would work but doesn't preserve colors
          html2canvas(outputContainer).then(canvas => {
            const link = document.createElement('a');
            link.download = 'ascii-art.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
          });
        } else {
          // For monochrome, we can draw text directly
          const lines = asciiOutput.textContent.split('\n');
          const lineHeight = parseInt(window.getComputedStyle(asciiOutput).lineHeight);
          
          lines.forEach((line, i) => {
            context.fillText(line, 10, 10 + (i * lineHeight));
          });
          
          // Create download link
          const link = document.createElement('a');
          link.download = 'ascii-art.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
        }
      }
      
      // Simple implementation of html2canvas-like functionality for this demo
      function html2canvas(element) {
        return new Promise((resolve) => {
          const canvas = document.createElement('canvas');
          canvas.width = element.offsetWidth;
          canvas.height = element.offsetHeight;
          const ctx = canvas.getContext('2d');
          
          // Draw background
          ctx.fillStyle = '#050505';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw content as an image using foreignObject in SVG
          const data = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}">
            <foreignObject width="100%" height="100%">
              <div xmlns="http://www.w3.org/1999/xhtml">
                ${element.innerHTML}
              </div>
            </foreignObject>
          </svg>`;
          
          const img = new Image();
          img.onload = () => {
            ctx.drawImage(img, 0, 0);
            resolve(canvas);
          };
          img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(data);
        });
      }
      
      function setupMatrixEffect() {
        const ctx = matrixCanvas.getContext('2d');
        matrixCanvas.width = dropArea.offsetWidth;
        matrixCanvas.height = dropArea.offsetHeight;
        
        const characters = '„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥0123456789';
        const columns = matrixCanvas.width / 15;
        const drops = [];
        
        for (let i = 0; i < columns; i++) {
          drops[i] = Math.floor(Math.random() * matrixCanvas.height / 15);
        }
        
        function draw() {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
          ctx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
          
          ctx.fillStyle = '#0f0';
          ctx.font = '15px monospace';
          
          for (let i = 0; i < drops.length; i++) {
            const text = characters[Math.floor(Math.random() * characters.length)];
            ctx.fillText(text, i * 15, drops[i] * 15);
            
            if (drops[i] * 15 > matrixCanvas.height && Math.random() > 0.975) {
              drops[i] = 0;
            }
            
            drops[i]++;
          }
        }
        
        setInterval(draw, 33);
      }
      
      // Handle window resize
      window.addEventListener('resize', () => {
        matrixCanvas.width = dropArea.offsetWidth;
        matrixCanvas.height = dropArea.offsetHeight;
      });
    });
  </script>
</body>
</html>